//
//  GameScene.swift
//  Finnopoly
//
//  Created by CHAN CHI YU on 22/10/2019.
//  Copyright Â© 2019 Finnopoly. All rights reserved.
//

import SpriteKit
import SwiftGraph


class GameScene: SKScene {
    
    var viewController: UIViewController!
    let serialQueue: DispatchQueue = DispatchQueue(label: "serialQueue")
    
    var diceNum: Int?
    var stationVertices : [String] = []
    var routeGraph: UnweightedGraph<String>!
    var worldNode: SKNode!
    var player: Player?
    
    var rollDiceBtnSprite : SKAControlSprite!
    var rollDiceForegroundSprite : RollDice!
    var rollDiceMask : RollDice!
    var toRoll = true
    var myMoves : Int = 0
    
    var pepeCam = SKCameraNode()
        
    //test player
    var npc: Player?
    
    //hihihihihi
    func generateOriginalPrice() -> Double {
        // Generate Random Value
        // Current Original Price Range: $80~600
        let rand1 = Int.random(in: 0..<41), rand2 = Int.random(in: 1..<8), constant = 80
        let price = Double(rand2*constant+rand1)
        return price
    }
    
    
    func initProp() {
        // initialize maxInvestment & originalPrice of a prop
        // originalPrice is generated by random, by func generateOriginalPrice()
        // maxInvestment is generated by (consant*originalPrice) i.e. 5 times of originalPrice
        
        let maxConstant = 5.0 // Just a factor for setting max Investment
        for name in self.stationVertices {
            if let prop = self.getProperty(stationName: name){
                // setPrice of Each Node
                let newOriginalPrice = self.generateOriginalPrice()
                prop.setProperties(maxInvestment: maxConstant*newOriginalPrice, originalPrice: newOriginalPrice)
                // setLevel based on Price. Which should affect the display image of housing
                prop.setPropLevel()
                
            }
        }
        
        print("*********Success Prop initialization *************")
    }
    
    func initPlayer(){
        player = getPlayer(playerName: "Pepe")
    }
    
    //prompt a alert if there is two or more paths
    func alertNextMove(stations: [Station]){
        let alertController = UIAlertController(title: "Please select your next move", message: "You have \(player!.remainSteps) steps left", preferredStyle: .alert)
        
        
        for station in stations {
            alertController.addAction(UIAlertAction(title: "\(station.name!)",style: .default, handler: {
                (action: UIAlertAction!) in
                self.move(node: self.player!, to: station.name!)
                DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                    self.updatePlayerPosition(player: self.player!) //recursion
                }
            }))
        }
        
        self.viewController.present(alertController, animated: true, completion: nil)
        
    }
    
    func alertBuy(prop: Property, playerBuy: Player) {
        let alertController = UIAlertController(title: "\(prop.name!) meet!" ,message: "Do you want to spend $ \(Int(prop.originalPrice)) to buy \(prop.name!) ?", preferredStyle: .alert)
        
        // Yes Option
        alertController.addAction(UIAlertAction(title: "Yes", style: .default, handler: {
            (action: UIAlertAction!) in
            self.propBuy(prop: prop, player: playerBuy)
            
        }))
        
        // No Option
        alertController.addAction(UIAlertAction(title: "No", style: .default, handler: {
            (action: UIAlertAction!) in
            print("No Buy Property \(prop.name!)")
        }))
        self.viewController.present(alertController, animated: true, completion: nil)
    }
    
    func propBuy(prop: Property, player: Player) {
        prop.owner = player.name!
        player.walletAmount! -= prop.originalPrice
        prop.setPropLevel() // Change Display image -> from house_0 to house_x
        print("*** System: Buy Complete *** \(player.name!) buys \(prop.name!)")
        print("**************************** Updated \(player.name!) 's wallet: \(player.walletAmount!)")
        
        prop.printDebug()
    }
    
    func alertInvest(prop: Property, playerInvest: Player) {
        
        // *** Data Validation: Max Investment not yet handle
        
        
        let alertController = UIAlertController(title: "\(prop.name!) meet!" ,message: "Do you want to invest \(prop.name!) ?", preferredStyle: .alert)
        
        // $20000 Option
        alertController.addAction(UIAlertAction(title: "$20000", style: .default, handler: {
            (action: UIAlertAction!) in
            self.propInvest(prop: prop, player: playerInvest, amount: 20000.0)
            
        }))
        
        // $10000
        alertController.addAction(UIAlertAction(title: "$10000", style: .default, handler: {
            (action: UIAlertAction!) in
            self.propInvest(prop: prop, player: playerInvest, amount: 10000.0)
            
        }))
        
        // $1000
        alertController.addAction(UIAlertAction(title: "$1000", style: .default, handler: {
            (action: UIAlertAction!) in
            self.propInvest(prop: prop, player: playerInvest, amount: 1000.0)
            
        }))
        // $0 Option
        alertController.addAction(UIAlertAction(title: "$0", style: .default, handler: {
            (action: UIAlertAction!) in
            print("No Invest Property \(prop.name!)")
        }))
        self.viewController.present(alertController, animated: true, completion: nil)
    }
    
    func propInvest(prop: Property, player: Player, amount: Double) {
        prop.curInvestment += amount
        player.walletAmount! -= amount
        prop.setPropLevel() // change display image from house_a to house_b based on investment
        print("*** System: Invest Complete *** \(player.name!) invests \(prop.name!)")
        print("**************************** Updated \(player.name!) 's wallet: \(player.walletAmount!)")
        
        prop.printDebug()
    }
    
    func alertToll(prop: Property, playerPay: Player, playerReceive: Player) {
        let alertController = UIAlertController(title: "\(prop.name!) meet!" ,message: "You need to pay \(Int(prop.tollPrice)) to \(playerReceive.name!)!", preferredStyle: .alert)
        
        //
        alertController.addAction(UIAlertAction(title: "Close", style: .default, handler: {
            (action: UIAlertAction!) in
            self.propPayToll(prop: prop, payer: playerPay, receiver: playerReceive )
            
        }))
        
        self.viewController.present(alertController, animated: true, completion: nil)
    }
    
    func propPayToll(prop: Property, payer: Player, receiver: Player) {
        payer.walletAmount! -= prop.tollPrice
        //receiver.walletAmount! += prop.tollPrice
        print("*** System: Pay Toll Complete *** \(payer.name!) pay \(prop.tollPrice) to \(receiver.name!)")
        print("**************************** Updated \(payer.name!) 's wallet: \(payer.walletAmount!)")
        receiver.walletAmount! += prop.tollPrice
        print("**************************** Updated \(receiver.name!) 's wallet: \(receiver.walletAmount!)")
    }
    
    
    override func didMove(to view: SKView) {
        super.didMove(to: view)
        
        worldNode = self
        getCityGraph()
        initProp()
        initPlayer()
    }
    override func didMove(to view: SKView) {
        print("did move")
        //move the playerNode into brown1
        move(node: player!, to: "brown1")
    }
    
    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        diceNum = rollDice()
        player?.remainSteps = diceNum!
        serialQueue.sync {
            self.updatePlayerPosition(player: self.player!)
        }
    }
    
    
    
    override func update(_ currentTime: TimeInterval) {
        // Called before each frame is rendered
        super.update(currentTime)
        
        // update camera position in each frame
        let camera = pepeCam, pepe = player
        camera.position = pepe!.position
    }
    
    //MARK: -Scene Initialization
    /***************************************************************/
    
    ///to mapped the routeMap into Graph, with stationName as vertices
    func getCityGraph(){
        //        let stationGraph: WeightedGraph<structStation, Int> = WeightedGraph<structStation, Int>()
        for child in worldNode.children {
            if child.name == "routeMap" {
                for station in child.children {
                    
                    if let tempName = station.name{
                        stationVertices.append(tempName)
                    }
                }
            }
        }
        //assign to the Graph
        routeGraph = UnweightedGraph<String>(vertices: stationVertices)
        print(routeGraph.vertexCount)
        
        graphConnection()
    }
    //called in getCityGraph function
    func graphConnection(){
        //initialize the connection between station
        let lineColors = ["brown","orange","red","blue","purple","pink","cyan","grey","greenN","greenS"]
        let mapNode = worldNode.childNode(withName: "routeMap")!
        
        for color in lineColors {
            //            print(color)
            var stationArray = [String]() //store the stations for particular color line
            let nameCount: Int = mapNode.getCountWithName(withName: color)
            
            mapNode.enumerateChildNodes(withName: "*\(color)*"){ //help append all station into the Array with same color
                node, _ in
                stationArray.append(node.name!)
            }
            
            ///brown0<->brown1<->brown2<->brown3<->brown4
            /// for i in 0 to 3 so
            ///brown0<->brown1, brown1<->brown2, brown3<->brown4
            for i in 0...nameCount - 2 {
                let fromIndex: Int = (stationArray.firstIndex(where: {$0.contains(color + String(i)) } )!)
                let toIndex: Int = (stationArray.firstIndex(where: {$0.contains(color + String(i+1)) } )!)
                routeGraph.addEdge(from: stationArray[fromIndex],to: stationArray[toIndex], directed: false)
                //print(stationArray[fromIndex] + " is connected to " + stationArray[toIndex])
            }
            
        }
    }
    
}

extension GameScene {
    
    ///this function helps to move a Player node into particular station and update the current station of the PlayerNode
    /// - parameter node: the node as a Player
    /// - parameter station: thes station name as String
    func move(node: Player, to station: String){
        let newPos = (self.getStation(stationName: station)!).position
        let moveAction = SKAction.move(to: newPos, duration: 1.0)
        moveAction.timingMode = .easeOut
        node.run(moveAction)
        //assignment the currentStation
        node.previousStation = node.currentStation
        node.currentStation = station
        if player!.remainSteps > 0 {
            player!.remainSteps -= 1
        }
    }
    
    ///this function helps to transverse the all properties
    func tranverseProperties (){
        print("-----Printing all propertie name -----")
        for name in stationVertices {
            
            if let prop = getProperty(stationName: name){
                print("*****************")
                prop.printDebug()
            }
        }
    }
    
    ///this function helps to update the player position according to the
    func updatePlayerPosition(player: Player){
        if player.remainSteps == 0 {
            
        }
        
        if player.remainSteps > 0 {
            let adjStation = getAdjacentStation(stationName: player.currentStation!)
            if adjStation.count == 1 {
                self.move(node: player, to: adjStation[0].name!)
                
                DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                    self.updatePlayerPosition(player: player) //recursion
                }
            } else if adjStation.count > 1 {
                alertNextMove(stations: adjStation)
                
            }
        }
        
    }
    
    //MARK: - Some Getter for Station, Property and Player by their stationName or playerName in the GameScene
    /***************************************************************/
    
    ///this function helps to retrieve the station of by StationName in GameScene.sks
    /// getStation is the function to accept statioName parametre and returns the Station node
    /// - parameter stationName: the name of the station
    func getStation(stationName: String) -> Station?{
        let stationNode = worldNode.childNode(withName: "routeMap")!.childNode(withName: stationName)!
        return (stationNode as! Station)
    }
    ///this function helps to retrieve the property of particular property by StationName in GameScene.sks
    /// getProperty is the function to accept statioName parametre and returns the property node
    /// - parameter stationName: the name of the station
    func getProperty(stationName: String) -> Property? {
        let stationNode = worldNode.childNode(withName: "routeMap")?.childNode(withName: stationName)!
        
        if (stationNode?.children.count)! > 0{
            let propertyNode = stationNode?.children.first as? Property
            //            propertyNode?.printDebug()
            return propertyNode
        } else {
            return nil
        }
    }
    
    
    ///this function helps to retrieve the Player by playerName =in GameScene.sks
    ///var player: Player = getPlayer(playerName: "pepe")
    /// - parameter playerName: the name of the player
    func getPlayer(playerName: String) -> Player? {
        let playerNode: Player? = self.worldNode.childNode(withName: playerName) as? Player
        return playerNode
    }
    
    func getAdjacentStation(stationName: String) -> [Station]{
        let stringArray = routeGraph.neighborsForVertex(stationName)?.filter({$0 != player?.previousStation})
        //        print(stringArray.debugDescription)
        let mappedArray = stringArray?.map({getStation(stationName: $0)!})
        //        print(mappedArray.debugDescription)
        return mappedArray!
    }
    
    
}

